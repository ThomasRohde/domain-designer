Got it. I’ll investigate the `domain-designer` repository, focusing on canvas usage and day-to-day modeling workflows in the browser. I’ll identify three high-impact, unreported bugs that negatively affect user experience and then create a developer-ready PRD with specific recommendations to fix them.

I’ll report back once I’ve completed the review and documentation.


# Identified Issues in the Domain Designer Canvas

## Bug 1: Child Rectangles Not Moving with Parent During Drag

**Behavior:** When a user drags a container rectangle (a parent with children) on the canvas, its child rectangles do **not** move along with it in real time. The parent’s position updates under the cursor, but the children remain in their original coordinates until the drag ends, then suddenly “jump” to re-align inside the parent’s new location.

**Context:** This occurs because the application only allows top-level “root” rectangles to be draggable, and defers updating child positions until after the drag completes. The code shows that if a rectangle has a `parentId` (i.e. is not a root), the drag handler exits early, preventing dragging of that item. During a drag of a parent, the children’s coordinates are left unchanged. Only on mouse up does the app recalculate child layouts inside the moved parent (via `updateChildrenLayout` on a short timeout). The rendering logic positions each rectangle absolutely on the canvas using its own `x,y` coordinates, so without updating those coords during the drag, children appear “left behind.”

**Impact:** This is very jarring for the user. Visually, it looks like the parent is being dragged out from under its contents, which remain floating in the old spot until the drag finishes. This disrupts the mental model of the diagram’s hierarchy and can confuse users about whether the child elements are actually linked. It degrades usability because the user cannot see an accurate preview of the final layout while dragging. It also makes positioning containers difficult – you have to “guess” where the children will end up. In a modeling tool, this undermines trust in the interface and slows down productivity (users may need to nudge or adjust repeatedly).

**Technical Details:** The root cause is that child rectangle positions are not updated in the drag loop. The `handleDragMove` function only adjusts the dragged rectangle’s `x, y`. Children are eventually repositioned by `updateChildrenLayout` when the drag ends, but not during the interaction. There is no grouping of child DOM elements under the parent; all rectangles are siblings in the canvas container, so moving the parent’s element alone does not affect children. This missing real-time sync is a clear bug in the canvas interaction design.

## Bug 2: Children Overlap When Parent is Resized Too Small

**Behavior:** If a user resizes a parent rectangle to be smaller than the space needed to lay out its children, the child rectangles will overlap or be squashed at the parent’s boundaries. The interface allows a container to be shrunk beyond what its contents can comfortably fit, resulting in children drawn on top of each other inside the parent.

**Context:** The layout engine is supposed to auto-size parents to contain children, but currently it only enforces a global minimum size (3 grid units, i.e. 60px) for any rectangle. A user can drag the resize handle of a parent down to this minimum regardless of how many children are inside. The child layout algorithm packs children in a grid within the parent, but if the parent is very small relative to the number of children, the code clamps child positions at the parent edges, effectively stacking them. For example, a parent at minimum width with two children (each with a minimum width of 3 grid units = 60px) will end up placing both children at the same `x` coordinate, since the parent’s internal width (after margins) is insufficient for even one child’s min size. The code confirms this: it calculates child positions in rows and columns and then does `Math.min(x, maxX)` for each child. If `maxX` (rightmost allowed position) is less than the intended `x`, multiple children get clamped to the same spot.

**Impact:** This bug severely affects the **correctness** of the visual model. Overlapping child nodes make the diagram unreadable – labels and shapes cover each other, and the user cannot distinguish or click the overlapped elements easily. It breaks the expectation that a container will grow or constrain itself to avoid collisions. From a UX perspective, it’s frustrating: a user might resize a container smaller expecting it to either reject the action or intelligently reflow children, but instead the contents just pile up. This can lead to lost time trying to “untangle” elements or manually fix the layout (the presence of a manual **Fit to children** action suggests users have to correct this themselves). Overall it degrades the usability and visual clarity of the modeling tool, especially as diagrams grow in complexity.

**Technical Details:** The resizing logic does not account for child layout requirements beyond the bare minimum per rectangle. In `handleResizeMove`, the new width/height are clamped only to a constant `MIN_WIDTH`/`MIN_HEIGHT`. There’s no check against the number or size of child elements. The layout algorithm `calculateChildLayout` will happily assign all children the minimum size and overlap them if the parent is too small. Essentially, the system lacks a **dynamic constraint** to prevent a parent from being sized smaller than its contents. This is why children can overflow or overlap instead of triggering the parent to resize larger (or limiting the resize).

## Bug 3: Undo/Redo Functionality Not Working (Missing History Management)

**Behavior:** The Undo/Redo feature – advertised in the README as “Full history management (Ctrl+Z / Ctrl+Y)” – is not actually functioning. Pressing **Ctrl+Z** or **Ctrl+Y** in the app does nothing to the diagram. There is no UI feedback or change in state, meaning users cannot easily revert mistakes or recover a previous modeling step.

**Context:** This appears to be an unimplemented feature, which is effectively a bug given user expectations. While keyboard shortcuts for Save (Ctrl+S), Load (Ctrl+O), etc. are handled, the code does not handle undo/redo keys. The custom hook for keyboard shortcuts listens for Ctrl/Cmd + keys and maps them to actions, but it has no case for 'z' or 'y'. Additionally, although the data model defines a history structure (an array of past rectangle states and an index) in the `DiagramState` type, the current implementation doesn’t update or use this for undo/redo. No state snapshots are being saved on each edit. Essentially, the plumbing for undo exists conceptually but isn’t wired up to any UI or logic.

**Impact:** Lack of Undo/Redo is a serious productivity hit. Modeling tasks involve trial and error – users frequently move or resize something then change their mind. Without undo, every mistake is costly: the user must manually fix the error (or reload the last saved file). This encourages very cautious interaction and frequent manual saves, which interrupts workflow. It also increases the risk of losing work (e.g. accidentally deleting a component cannot be undone, potentially wiping out a whole sub-tree of the model). Since the tool advertises undo/redo, users may try it and be confused or assume something is broken when nothing happens. This erodes confidence in the application and is a major UX gap for a modern editing tool.

**Technical Details:** The absence of undo/redo functionality is evident in the code. The `useKeyboardShortcuts` hook handles several keys but not Ctrl+Z/Y, and no other part of the app processes those shortcuts. The state management (via `useRectangleManager` and in-memory arrays) never snapshots or restores previous states. There is a placeholder for `MAX_HISTORY_SIZE` = 50 in constants, indicating the intention for a 50-step history buffer, but no corresponding logic to enforce or utilize it. This means the feature is effectively unimplemented, which is functionally equivalent to a bug given user expectations.

---

# Product Requirements Document: Canvas Interaction & Usability Fixes

## Problem Statement

The core diagram canvas of the Domain Designer has several bugs that disrupt the user’s ability to model domains intuitively and accurately. In particular, **(1)** child elements do not move with their parent during drag operations, **(2)** parent rectangles can be resized to a size smaller than their child elements (causing overlap and layout breakage), and **(3)** the Undo/Redo feature is non-functional. These issues undermine the usability of the modeling interface by causing confusion, layout errors, and inability to easily correct mistakes. The goal of this PRD is to outline fixes for these bugs, thereby improving the day-to-day modeling experience in the browser canvas.

## Impact Assessment

* **Real-time Drag Feedback:** The lack of synchronized dragging for parent and child shapes leads to a disjointed visual experience. Users have difficulty positioning grouped elements and may become frustrated or make positioning errors, slowing down their workflow. This is a fundamental interaction issue that *all* users will encounter when moving containers on the canvas.

* **Layout Integrity on Resize:** Allowing overlaps when resizing containers breaks the integrity of the model diagram. Important elements can become hidden or clumped, reducing diagram readability and professional appearance. Users might unknowingly save or export diagrams with overlapping components, which is a serious quality issue. It also forces extra steps (like manually clicking “Fit to children”) to fix something the software should handle automatically.

* **Undo/Redo Absence:** Without Undo, every action is effectively permanent unless manually reversed. This dramatically increases user anxiety and reduces experimentation. A single mistake (e.g. deleting the wrong object) could require rebuilding parts of the model. This bug impacts user **confidence and efficiency** – core metrics for a modeling tool’s success – and puts the application behind standard expectations for any design/editing software.

Overall, these bugs impede user **productivity**, introduce **errors** into models, and create a steep learning curve (users must remember workarounds or be extra cautious). Fixing them will greatly enhance the fluidity and reliability of the modeling experience, leading to happier users and more polished outputs.

## Proposed Solution

**1. Synchronized Parent-Child Drag:** Modify the canvas interaction logic so that when a parent rectangle (root or any container) is dragged, all its descendant rectangles move together in real time. The drag operation should treat a parent and its children as one cohesive group. Technically, we can achieve this by updating child coordinates relative to the parent’s movement on each drag update, or by nesting the child elements inside the parent’s DOM element so they naturally move together. The simplest approach is to calculate the same delta movement applied to the parent and add it to each child’s `x, y` during the drag. This ensures the whole hierarchy appears to move as a unit under the cursor.

**2. Enforce Minimum Container Size based on Children:** Introduce dynamic constraints during resize operations. The system should prevent a user from shrinking a parent rectangle so much that its children would overlap or overflow. In practice, we will compute the **minimum allowable width and height** for the container based on its current children. If the user tries to drag the resize handle beyond that minimum, the container will stop resizing further (visually “locking” at the minimum size). The `calculateMinimumParentSize` function (or equivalent logic) can be used to determine this threshold. This way, the parent will always remain just large enough to neatly contain its children (respecting margins and child minimum sizes). If children themselves have flexible sizing, the algorithm can also shrink the children within their minimums, but at no point should two children overlap. Essentially, the auto-layout should always maintain a valid non-overlapping state, either by resizing children or stopping further parent shrinkage.

**3. Implement Undo/Redo History:** Fully implement the undo/redo functionality with a command history stack. Every change to the diagram state (adding or deleting a rectangle, moving/resizing, label edit, color change, etc.) should push a snapshot of the state onto an **undo stack**. We will maintain an in-memory history of up to 50 states (as per the design constant). Pressing **Ctrl+Z** will revert the state to the last snapshot, and pressing **Ctrl+Y** (or Ctrl+Shift+Z) will reapply an undone state. We should integrate this with the existing state management: for example, wrap the `setRectangles` updates in a function that also logs the previous state. We’ll add keyboard shortcut handling for 'Z' and 'Y' in the `useKeyboardShortcuts` hook to trigger these actions. Additionally, if the UI has toolbar buttons or menu entries for Undo/Redo in the future, they should tie into the same history mechanism. This solution ensures users can safely experiment, knowing they can reverse actions, and brings the app in line with standard editing software behavior.

## Technical Requirements

* **Canvas Drag Logic:** Update the `useDragAndResize` hook (or related drag handling code) to account for child elements during drag. Specifically:

  * Detect when the dragged rectangle has children (e.g. check if any `rect.parentId === draggedRect.id` or use a precomputed descendant list).
  * During `handleDragMove`, if dragging a container with children, update each child’s coordinates by the same `(deltaX, deltaY)` applied to the parent. This could be done by calling `setRectangles` with a function that maps over all rectangles: for each rectangle, if it is the dragged rect or one of its descendants, add the delta to its `x` and `y`.
  * Ensure that the `updateChildrenLayout` function (called on drag end) either isn’t duplicating movement or interfering. We may need to adjust or skip the final re-layout if we’ve been moving children live. Alternatively, if we nest child DOM elements (changing the render structure so that a parent contains its children in the DOM), then dragging the parent’s DOM wrapper would naturally drag children. This DOM approach requires more refactoring (e.g. rendering child components inside parent component), so the coordinate-shifting approach is likely quicker and less invasive.
  * Test that when dragging any container, the relative positions of children remain constant throughout (no lag or independent movement). The cursor should ideally stay on the dragged item (we might need to adjust the drag offset calculation if children cause any reflow).

* **Resize Constraints:** Enhance the `handleResizeMove` logic in `useDragAndResize`:

  * After computing tentative `newW, newH` for the resized rectangle, check if that rectangle has children. If yes, compute the minimum width/height required: e.g. call a `calculateMinimumParentSize(resizingRectId)` function that considers current children count, each child’s min size, and margins. (This function exists in `layoutUtils.ts` and can be utilized or updated as needed.)
  * Compare the tentative new dimensions with the minimum. If the new width is below min, set it to the min. Same for height.
  * Update the rectangle with the clamped size. This will automatically prevent overlap because we’re not allowing the container to shrink past where children can fit.
  * Additionally, ensure that as the user resizes larger, children expand or reposition correctly (the existing `updateChildrenLayout` should handle that on mouse up). When resizing smaller, children might shrink down to their own minimum; if the algorithm doesn’t currently shrink child sizes when space is tight, consider updating it to reduce child `w,h` (but not below MIN\_WIDTH/MIN\_HEIGHT) to pack them in a smaller parent. However, the primary requirement is **no overlap** – children can scroll or be cut off if extremely small, but they should not visually stack on each other.
  * The UI should give feedback when the min size is reached (e.g. the resize handle could just stop moving further in that direction). We should test edge cases: container with many children, container with one child (min size then just equals that child’s min), and nested containers (the constraint should recurse if needed).

* **History State Management:** Introduce a global or context-based state for undo/redo:

  * Add a **history stack** (array) and an index pointer to the main state (e.g. in `useRectangleManager` or a new `useHistory` hook). For example, maintain `history: Rectangle[][]` and `historyIndex`.
  * Whenever a state-changing action occurs (add rectangle, remove, move, resize, label edit, color change), do the following:

    * If the action is invoked, and we are at the end of the history (no undone actions waiting), push a deep copy of the *prior* state of `rectangles` onto the history array, then cap the history length to 50 by removing the oldest if necessary. Then allow the new change to apply. Increment `historyIndex`.
    * If an action occurs when some undos have been done (historyIndex not at the top), we should discard any “redo” states ahead in the stack before pushing the new state (this is standard undo/redo behavior).
  * Implement undo: if Ctrl+Z is pressed and `historyIndex > 0`, set the `rectangles` state back to a copy of `history[historyIndex - 1]`, and decrement `historyIndex`. Implement redo similarly: if Ctrl+Y and `historyIndex < history.length - 1`, move forward by one, restoring that state.
  * Integrate these with keyboard events: modify `useKeyboardShortcuts` to call `onUndo` and `onRedo` callbacks. We will add `onUndo` and `onRedo` to the hook’s interface and handle the 'z' and 'y' keys when `ctrlKey` is down. Also ensure that these keys don’t trigger browser defaults (e.g. prevent default so the browser doesn’t interpret Ctrl+Z in a text field context when the focus is on the canvas).
  * Test the history thoroughly: multiple undos in a row, redo after undo, undo after adding then deleting elements, etc. The history should include all user-initiated changes to `rectangles`. Non-rectangle state (like UI panel open/close) need not be part of undo – we focus on model changes.
  * Memory considerations: 50 states of moderate diagram size should be fine (and is the intended limit). But ensure that copying state (which could be an array of rectangle objects) is done by value (structured clone or manual copy) to avoid accidental mutations of history entries.

## User Acceptance Criteria

* **Smooth Group Drag:** When the user drags a parent rectangle that contains children, all those child rectangles move **together seamlessly** during the drag. There should be no moment where children are left behind. Visually, the structure behaves like a grouped object. For example, if I have a root box with three leaf nodes inside and I click-drag the root, I should see the three leaf nodes staying in their same relative positions inside that root as it moves. The drop behavior should be consistent – after releasing, the children might slightly adjust to the grid, but they should already be very close to their final position because they were moving along. The user should perceive it as one fluid motion. Also, selecting and dragging a root with many nested levels should not degrade performance significantly; it should still track the mouse reasonably well.

* **No Overlap on Resize:** The user cannot accidentally create an overlapping layout by resizing. Acceptance examples:

  * If a container has multiple children and I drag its bottom-right resize handle inward, it will stop shrinking at a certain point where any further and the children would collide. At that stopping point, all children are still neatly arranged (perhaps small, but not on top of one another). The resize handle should not overshoot and cause any visual overlap or spill-out. If I release at that point, the layout remains clean.
  * If I then add another child to that tightly packed container, the parent should automatically grow (or the children resize) to accommodate the new one, because the constraint will update – i.e. the system should never leave it in an overlapped state after any operation.
  * Essentially, *at all times*, for any given diagram state, if a parent is drawn, its children are visible and separated within it. Users might notice that they can’t make a parent as small as they want if it has many children – that’s acceptable, as long as the rule (no hidden/overlapping children) is maintained. This will be communicated through the interface by the resize simply halting.

* **Fully Functional Undo/Redo:** Users are able to undo and redo changes reliably. Specific criteria:

  * Pressing **Ctrl+Z** (or Cmd+Z on Mac) will revert the last change made to the diagram. If I move a shape, Ctrl+Z moves it back to its previous position. If I delete an object, Ctrl+Z brings it (and its sub-tree) back. If I add a new rectangle, Ctrl+Z removes it. This should work for style changes too (e.g. label text changes or color changes should undo to the previous value).
  * Pressing **Ctrl+Y** (or Ctrl+Shift+Z) re-applies an undone action. So if I undo a deletion, Ctrl+Y will delete the object again, etc.
  * The history should be linear and consistent. For instance, if I undo 3 steps, then perform a new action, I cannot redo those 3 (they should be cleared from the forward history). The implementation should match typical software behavior in this regard.
  * There should be no crashes or corrupt state when doing many undos/redos in succession. The limit of 50 should simply start dropping the oldest states without error.
  * (If any UI indicator for undo/redo is present, it should correctly enable/disable based on available history, but if not, at least the keyboard works as expected.)
  * Importantly, undo should also cover changes from drag/resize operations as single actions. Even though dragging might update position state continuously, the entire drag from start to drop is treated as one action to undo. So after moving a shape and releasing it, one Ctrl+Z should put it back where it started before the drag began (we’ll achieve this by pushing the state only when the drag finishes, not every pixel it moved).

By meeting these criteria, the application will provide a far more intuitive and forgiving modeling experience. Users will be able to manipulate the canvas confidently, knowing that containers behave predictably and mistakes can be undone. This will directly translate into better productivity and satisfaction with the Domain Designer tool.

**Sources:**

* Application code analysis of canvas interactions, layout calculations, and shortcut handling from the Domain Designer repository. These informed the technical causes of the issues and guided the solution design.
